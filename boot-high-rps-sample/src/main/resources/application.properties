spring.application.name=boot-highrps-app
server.port=8080
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

spring.jmx.enabled=false

# Enable virtual threads (Spring Boot 4 support)
spring.threads.virtual.enabled=true
spring.mvc.problemdetails.enabled=true

# Redis (lettuce) defaults tune for production Redis cluster
spring.data.redis.client-type=lettuce

# Lettuce pool tuning (example values from the article)
spring.data.redis.lettuce.pool.max-active=1024
spring.data.redis.lettuce.pool.max-wait=500ms
spring.data.redis.lettuce.pool.max-idle=512
spring.data.redis.lettuce.pool.min-idle=10

management.endpoints.web.exposure.include=health,info,prometheus

# Server tuning hints from the article (subject to kernel tuning)
server.max-http-request-header-size=16384
# With virtual threads enabled, platform thread pool tuning is less relevant
#server.tomcat.threads.max=100000
server.tomcat.connection-timeout=20000
server.tomcat.threads.max=50
server.tomcat.threads.min-spare=10
server.tomcat.max-connections=1000

# Kafka for async writes
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JacksonJsonSerializer
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.streams.application-id=${spring.application.name}
# Dev: if internal changelog offsets mismatch, reset to earliest and cleanup local state
spring.kafka.streams.properties.auto.offset.reset=earliest
#spring.kafka.streams.state-dir=./kafka-streams-state

spring.testcontainers.beans.startup=parallel

################ Database #####################
spring.jpa.show-sql=false
spring.jpa.open-in-view=false
spring.data.jpa.repositories.bootstrap-mode=deferred
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.auto-commit=false
spring.datasource.hikari.pool-name=HikariPool-${spring.application.name}
spring.datasource.hikari.data-source-properties.ApplicationName=${spring.application.name}
spring.datasource.hikari.data-source-properties.cachePrepStmts=true
spring.datasource.hikari.data-source-properties.prepStmtCacheSize= 500
spring.datasource.hikari.data-source-properties.prepStmtCacheSqlLimit= 2048
spring.datasource.hikari.data-source-properties.useServerPrepStmts= true
spring.datasource.hikari.data-source-properties.useLocalSessionState= true
spring.datasource.hikari.data-source-properties.rewriteBatchedStatements= true
spring.datasource.hikari.data-source-properties.cacheResultSetMetadata= true
spring.datasource.hikari.data-source-properties.cacheServerConfiguration= true
spring.datasource.hikari.data-source-properties.elideSetAutoCommits= true
spring.datasource.hikari.data-source-properties.maintainTimeStats= false
spring.jpa.hibernate.ddl-auto=none
#spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.time_zone=UTC
spring.jpa.properties.hibernate.generate_statistics=false
spring.jpa.properties.hibernate.jdbc.batch_size=25
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.query.fail_on_pagination_over_collection_fetch=true
spring.jpa.properties.hibernate.query.in_clause_parameter_padding=true
spring.jpa.properties.hibernate.query.plan_cache_max_size=4096
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# Batch processor settings
app.batch.queue-key=events:queue
app.batch.size=100
app.batch.delay-ms=5000

# JVM hints (informational only) - tune as required for performance
# Recommended JVM flags in production: -XX:+UseZGC -Xms1g -Xmx2g -XX:+UseCompressedOops

app.kafka.events-topic.partitions=3
app.kafka.events-topic.replication-factor=1
app.kafka.posts-aggregates-topic.partitions=3
app.kafka.posts-aggregates-topic.replication-factor=1
# How long to retain tombstones (null values) after a delete in milliseconds.
# Default: 7 days (604800000 ms). Must be long enough to let compacted log cleanup
# remove tombstones after downstream state stores have processed deletions.
app.kafka.events-topic.tombstone-retention-ms=604800000
app.kafka.publish-time-out-ms=5000
